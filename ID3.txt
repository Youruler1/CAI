# -*- coding: utf-8 -*-
"""ID3 Algorithm (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oNawl1S52BqOO6DxttfJDlN0HD5qBO-T
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import pandas as pd



def find_entropy(df):
    Class=df.keys()[-1]        # 'Play'
    values=df[Class].unique()  #array([0, 1])
    entropy=0
    for value in values:
        print(value)
        prob=len(df[df[Class]==value])/len(df[Class])
        entropy+=-prob*np.log2(prob)
    return entropy

df=pd.read_csv('/content/drive/MyDrive/CONVAI/CONVAI_MATERIAL/LAB/6th/weather.csv')

df.keys()

find_entropy(df)

df[df[Class]==0]

def find_information_entropy(df,attribute):
    Class=df.keys()[-1]
    labels=df[Class].unique()
    attr_values=df[attribute].unique()
    avg_entropy=0
    for value1 in attr_values:
        entropy_subsample=0
        for value2 in labels:
            #num=len(df[attribute][df[attribute]==value1][df[Class]==value2])
            #den=len(df[attribute][df[attribute]==value1])
            num = len(df[(df[attribute] == value1) & (df['Class'] == value2)])
            den = len(df[df[attribute] == value1])

            prob=num/den
            entropy_subsample+=-(prob*np.log2(prob+1e-7))
        weight=den/len(df)
        avg_entropy+=weight*entropy_subsample
    return avg_entropy

find_information_entropy(df,'Humidity')

def find_winner(df):
    IG=[]
    for attribute in df.keys()[:-1]:
        IG.append(find_entropy(df)-find_information_entropy(df,attribute))
    return df.keys()[:-1][np.argmax(IG)]

find_winner(df)

def training(df,tree=None):
    Class=df.keys()[-1]
    split_attr=find_winner(df)
    split_attr_values=df[split_attr].unique()
    if tree is None:
        tree={}
        tree[split_attr]={}
    for value in split_attr_values:
        sub_df=df[df[split_attr]==value].reset_index(drop=True)
        #Clvalue,count=np.unique(sub_df[Class],return_counts=True)
        Clvalue=sub_df[Class].unique()
        if len(Clvalue)==1:
            tree[split_attr][value]=Clvalue[0]
        else:
            tree[split_attr][value]=training(sub_df)
    return tree

tree=training(df)

import pprint
pprint.pprint(tree)

def predict(inst,tree):
    for nodes in tree.keys():
        value=inst[nodes]
        tree=tree[nodes][value]
        prediction=0
        if type(tree) is dict:
            prediction=predict(inst,tree)
        else:
            prediction=tree
            break;
    return prediction

df1=pd.read_csv('/content/drive/MyDrive/CONVAI/CONVAI_MATERIAL/LAB/6th/weather_test.csv')
Y_label=[]
for i in range(len(df1)):
    inst=df1.iloc[i,:]
    prediction=predict(inst,tree)
    Y_label.append(prediction)

Y_label

from sklearn import metrics
print(metrics.classification_report(df1.iloc[:,-1],Y_label))

